import java.util.Arrays; 
import java.util.HashMap; 
import java.util.Map; 
import java.util.Scanner; 
 
public class ColumnarTranspositionCipher { 
 
    // Helper method to get the permutation order based on the key 
    private static int[] getPermutationOrder(String key) { 
        // Create a map to store character and its original index 
        Map<Character, Integer> keyMap = new HashMap<>(); 
        for (int i = 0; i < key.length(); i++) { 
            keyMap.put(key.charAt(i), i); 
        } 
 
        // Sort the key characters to determine the new column order 
        char[] sortedKeyChars = key.toCharArray(); 
        Arrays.sort(sortedKeyChars); 
 
        // Create an array to store the permutation order (original index of sorted characters) 
        int[] permutationOrder = new int[key.length()]; 
        for (int i = 0; i < key.length(); i++) { 
            permutationOrder[i] = keyMap.get(sortedKeyChars[i]); 
        } 
        return permutationOrder; 
    } 
 
    public static String encrypt(String plaintext, String key) { 
        plaintext = plaintext.replaceAll(" ", "").toUpperCase(); // Remove spaces and convert to 
uppercase 
        key = key.toUpperCase(); 
 
        int numCols = key.length(); 
        int numRows = (int) Math.ceil((double) plaintext.length() / numCols); 
 
        char[][] matrix = new char[numRows][numCols]; 
        int k = 0; 
        for (int i = 0; i < numRows; i++) { 
            for (int j = 0; j < numCols; j++) { 
                if (k < plaintext.length()) { 
                    matrix[i][j] = plaintext.charAt(k++); 
                } else { 
                    matrix[i][j] = 'X'; // Padding with 'X' 
                } 
            } 
        } 
 
        int[] permutationOrder = getPermutationOrder(key); 
        StringBuilder ciphertext = new StringBuilder(); 
 
        for (int colIndex : permutationOrder) { 
            for (int i = 0; i < numRows; i++) { 
                ciphertext.append(matrix[i][colIndex]); 
            } 
        } 
        return ciphertext.toString(); 
    } 
 
    public static String decrypt(String ciphertext, String key) { 
        key = key.toUpperCase(); 
 
        int numCols = key.length(); 
        int numRows = (int) Math.ceil((double) ciphertext.length() / numCols); 
 
        char[][] matrix = new char[numRows][numCols]; 
        int[] permutationOrder = getPermutationOrder(key); 
 
        int charIndex = 0; 
        for (int colOrderIndex = 0; colOrderIndex < numCols; colOrderIndex++) { 
            int originalColIndex = permutationOrder[colOrderIndex]; 
            for (int i = 0; i < numRows; i++) { 
                matrix[i][originalColIndex] = ciphertext.charAt(charIndex++); 
            } 
        } 
 
        StringBuilder plaintext = new StringBuilder(); 
        for (int i = 0; i < numRows; i++) { 
            for (int j = 0; j < numCols; j++) { 
                if (matrix[i][j] != 'X') { // Remove padding 
                    plaintext.append(matrix[i][j]); 
                } 
            } 
        } 
        return plaintext.toString(); 
    } 
 
    public static void main(String[] args) { 
        Scanner scanner = new Scanner(System.in); 
 
        System.out.print("Enter plaintext: "); 
        String plaintext = scanner.nextLine(); 
 
        System.out.print("Enter key: "); 
        String key = scanner.nextLine(); 
 
        String encryptedText = encrypt(plaintext, key); 
        System.out.println("Encrypted text: " + encryptedText); 
 
        String decryptedText = decrypt(encryptedText, key); 
        System.out.println("Decrypted text: " + decryptedText); 
 
        scanner.close(); 
    } 
} 
