import java.util.*;
import java.math.BigInteger;

class dsaAlg {

    static BigInteger one = BigInteger.ONE;

    // Generate a prime q of given bit length
    static BigInteger generatePrime(int bits, Random r) {
        BigInteger q;
        do {
            q = new BigInteger(bits, r);
        } while (!q.isProbablePrime(80));
        return q;
    }

    // Generate prime p = kq + 1
    static BigInteger generateP(BigInteger q, Random r) {
        BigInteger k, p;
        while (true) {
            k = new BigInteger(512, r);
            p = k.multiply(q).add(one);
            if (p.isProbablePrime(80))
                return p;
        }
    }

    // Find generator g
    static BigInteger generateG(BigInteger p, BigInteger q, Random r) {
        while (true) {
            BigInteger h = new BigInteger(p.bitLength(), r).mod(p);
            if (!h.equals(BigInteger.ZERO)) {
                BigInteger g = h.modPow(p.subtract(one).divide(q), p);
                if (!g.equals(BigInteger.ONE))
                    return g;
            }
        }
    }

    public static void main(String[] args) throws Exception {

        Random r = new Random();

        BigInteger q = generatePrime(64, r);
        BigInteger p = generateP(q, r);
        BigInteger g = generateG(p, q, r);

        BigInteger x = new BigInteger(q.bitLength(), r).mod(q);
        BigInteger y = g.modPow(x, p);

        BigInteger k;
        do {
            k = new BigInteger(q.bitLength(), r).mod(q);
        } while (k.equals(BigInteger.ZERO));

        BigInteger rVal = g.modPow(k, p).mod(q);

        BigInteger h = new BigInteger(q.bitLength(), r);

        BigInteger kInv = k.modInverse(q);
        BigInteger s = kInv.multiply(h.add(x.multiply(rVal))).mod(q);

        System.out.println("p: " + p);
        System.out.println("q: " + q);
        System.out.println("g: " + g);
        System.out.println("x: " + x);
        System.out.println("k: " + k);
        System.out.println("y: " + y);
        System.out.println("hash: " + h);
        System.out.println("r: " + rVal);
        System.out.println("s: " + s);

        BigInteger w = s.modInverse(q);
        BigInteger u1 = h.multiply(w).mod(q);
        BigInteger u2 = rVal.multiply(w).mod(q);

        BigInteger v = g.modPow(u1, p).multiply(y.modPow(u2, p)).mod(p).mod(q);

        System.out.println("v: " + v);

        if (v.equals(rVal))
            System.out.println("Signature Verified");
        else
            System.out.println("Signature Invalid");
    }
}
